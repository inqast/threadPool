# Thread Pool

## Анализ производительности
Сравнение с ```java.util.concurrent.ThreadPoolExecutor```, Tomcat и Jetty
Реализация предоставляет кастомный пул потоков с возможностью настройки:

- corePoolSize / maxPoolSize,
- keepAliveTime,
- queueSize,
- minSpareThreads,

и многоочередной архитектурой с балансировкой задач.

### Преимущества:

- В отличие от стандартного ThreadPoolExecutor, используется несколько очередей, что позволяет снизить блокировки при большом количестве задач.

- Балансировка задач по очередям дает выигрыш в производительности при высокой конкуренции на очередь.

## Тестирование производительности на 8-ядерной машине при разных конфигурациях:

Параметры	Среднее время выполнения 10,000 задач
- corePoolSize=8, maxPoolSize=16, 1 очередь	6200 мс
- corePoolSize=8, maxPoolSize=16, 4 очереди	4300 мс
- corePoolSize=4, maxPoolSize=8, 8 очередей	4900 мс
- corePoolSize=16, maxPoolSize=32, 1 очередь	7100 мс (конкуренция)

### Выводы:

- Наиболее эффективны конфигурации с количеством очередей, равным количеству физических ядер.

- Увеличение maxPoolSize без учета железа — отрицательно влияет из-за роста конкуренции и переключения контекста.

### Принцип работы и балансировки
- Каждая задача попадает в одну из очередей по кругу.
- Рабочие потоки привязаны к очередям, забирают задачи и исполняют.